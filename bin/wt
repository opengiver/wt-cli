#!/bin/bash
# wt - Worktree Management CLI
# Usage: wt <command> [args]
#
# Commands:
#   ls, list          List all worktrees and their status
#   cd <name>         Print cd command to worktree (use: cd $(wt cd <name>))
#   dev [name]        Start dev server in tmux (current or specified worktree)
#   dev-all           Start all worktrees in tmux session
#   stop [name|all]   Stop dev server(s)
#   attach            Attach to tmux session
#   ports             Show port assignments
#   open [name]       Open in browser (localhost:PORT)
#   link-env [name]   Link .env files from main repo to worktree
#   link-env-all      Link .env files to all worktrees
#   install [name]    Install dependencies in worktree
#   install-all       Install dependencies in all worktrees

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

INTERACTIVE_SESSION="wt-interactive-$$"

# Find project root (main repo, not worktree)
find_project_root() {
  local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
  
  if [[ -z "$git_root" ]]; then
    # Not in a git repo - check subdirectories for git repos
    local found_repos=()
    for dir in */; do
      if [[ -d "$dir/.git" ]] || [[ -f "$dir/.git" ]]; then
        found_repos+=("${dir%/}")
      fi
    done
    
    if [[ ${#found_repos[@]} -eq 1 ]]; then
      # Single repo found - use it
      git_root="$PWD/${found_repos[0]}"
    elif [[ ${#found_repos[@]} -gt 1 ]]; then
      # Multiple repos - check for worktrees dir pattern
      for repo in "${found_repos[@]}"; do
        if [[ -d "$PWD/${repo}-worktrees" ]]; then
          git_root="$PWD/$repo"
          break
        fi
      done
      # If still not found, use first one
      if [[ -z "$git_root" ]]; then
        git_root="$PWD/${found_repos[0]}"
      fi
    else
      echo ""
      return
    fi
  fi
  
  # Check if this is a worktree (has .git file instead of .git directory)
  if [[ -f "$git_root/.git" ]]; then
    local gitdir=$(cat "$git_root/.git" | sed 's/gitdir: //')
    echo "$gitdir" | sed 's/\/\.git\/worktrees\/.*//'
  else
    echo "$git_root"
  fi
}

PROJECT_ROOT=$(find_project_root)
if [[ -z "$PROJECT_ROOT" ]]; then
  echo -e "${RED}Error: No git repository found${NC}"
  echo -e "${DIM}Run from inside a git repo or a parent directory containing repos${NC}"
  exit 1
fi

PROJECT_NAME=$(basename "$PROJECT_ROOT")
WORKTREES_DIR="$(dirname "$PROJECT_ROOT")/${PROJECT_NAME}-worktrees"
TMUX_SESSION="${PROJECT_NAME}-dev"
BASE_PORT=3000

# Detect project type (checks root and common subdirectories)
detect_project_type() {
  local dir="${1:-$PWD}"
  
  # Check root first, then common subdirectories
  local check_dirs=("$dir" "$dir/app" "$dir/src" "$dir/client" "$dir/frontend" "$dir/mobile")
  
  for check_dir in "${check_dirs[@]}"; do
    if [[ -f "$check_dir/pubspec.yaml" ]]; then
      echo "flutter"
      return
    fi
  done
  
  for check_dir in "${check_dirs[@]}"; do
    if [[ -f "$check_dir/package.json" ]]; then
      echo "nodejs"
      return
    fi
  done
  
  if [[ -f "$dir/go.mod" ]]; then
    echo "go"
  elif [[ -f "$dir/Cargo.toml" ]]; then
    echo "rust"
  elif [[ -f "$dir/requirements.txt" ]] || [[ -f "$dir/pyproject.toml" ]]; then
    echo "python"
  else
    echo "generic"
  fi
}

# Find Flutter app directory (returns subdirectory if pubspec.yaml is not in root)
find_flutter_dir() {
  local dir="${1:-$PWD}"
  local check_dirs=("$dir" "$dir/app" "$dir/src" "$dir/client" "$dir/frontend" "$dir/mobile")
  
  for check_dir in "${check_dirs[@]}"; do
    if [[ -f "$check_dir/pubspec.yaml" ]]; then
      echo "$check_dir"
      return
    fi
  done
  
  echo ""
}

# Get dev command for project type
get_dev_command() {
  local dir="${1:-$PWD}"
  local port="${2:-3000}"
  local project_type=$(detect_project_type "$dir")
  
  case $project_type in
    flutter)
      local flutter_dir=$(find_flutter_dir "$dir")
      if [[ "$flutter_dir" != "$dir" ]] && [[ -n "$flutter_dir" ]]; then
        echo "cd '$flutter_dir' && flutter run --web-port=$port"
      else
        echo "flutter run --web-port=$port"
      fi
      ;;
    nodejs)
      # Find package.json location
      local pkg_dir="$dir"
      local check_dirs=("$dir" "$dir/app" "$dir/src" "$dir/client" "$dir/frontend")
      for check_dir in "${check_dirs[@]}"; do
        if [[ -f "$check_dir/package.json" ]]; then
          pkg_dir="$check_dir"
          break
        fi
      done
      
      if [[ -f "$pkg_dir/package.json" ]]; then
        local cd_prefix=""
        if [[ "$pkg_dir" != "$dir" ]]; then
          cd_prefix="cd '$pkg_dir' && "
        fi
        
        # Check if it's Next.js, Vite, or generic
        if grep -q '"next"' "$pkg_dir/package.json" 2>/dev/null; then
          echo "${cd_prefix}PORT=$port npm run dev"
        elif grep -q '"vite"' "$pkg_dir/package.json" 2>/dev/null; then
          echo "${cd_prefix}npm run dev -- --port $port"
        else
          echo "${cd_prefix}PORT=$port npm run dev"
        fi
      fi
      ;;
    go)
      echo "go run . --port $port"
      ;;
    python)
      echo "python -m flask run --port $port"
      ;;
    *)
      echo "echo 'Unknown project type'"
      ;;
  esac
}

# Get port for worktree (based on index)
get_worktree_port() {
  local wt_name="$1"
  local index=0
  
  for wt in "$WORKTREES_DIR"/*/; do
    if [[ -d "$wt" ]]; then
      local name=$(basename "$wt")
      if [[ "$name" == "$wt_name" ]]; then
        echo $((BASE_PORT + index))
        return
      fi
      ((index++))
    fi
  done
  
  # Default if not found
  echo $BASE_PORT
}

# Check if port is in use
is_port_in_use() {
  local port="$1"
  lsof -i ":$port" &>/dev/null
}

# List all worktrees
cmd_list() {
  echo -e "${CYAN}üìÅ Worktrees for ${PROJECT_NAME}${NC}"
  echo "========================================"
  echo ""
  
  # Main project
  local main_type=$(detect_project_type "$PROJECT_ROOT")
  echo -e "  ${BLUE}[main]${NC} $PROJECT_ROOT"
  echo -e "    Type: $main_type"
  echo -e "    Branch: $(cd "$PROJECT_ROOT" && git branch --show-current)"
  echo ""
  
  if [[ ! -d "$WORKTREES_DIR" ]]; then
    echo -e "  ${YELLOW}No worktrees found${NC}"
    echo -e "  Create with: git worktree add ../\${PROJECT}-worktrees/<name> <branch>"
    return
  fi
  
  local index=0
  for wt in "$WORKTREES_DIR"/*/; do
    if [[ -d "$wt" ]]; then
      local name=$(basename "$wt")
      local branch=$(cd "$wt" && git branch --show-current 2>/dev/null || echo "unknown")
      local port=$((BASE_PORT + index))
      local project_type=$(detect_project_type "$wt")
      
      # Check if dev server is running
      if is_port_in_use "$port"; then
        local status="${GREEN}‚óè Running${NC} on :$port"
      else
        local status="${YELLOW}‚óã Stopped${NC} (port $port)"
      fi
      
      echo -e "  ${BLUE}[$name]${NC}"
      echo -e "    Path: $wt"
      echo -e "    Branch: $branch"
      echo -e "    Type: $project_type"
      echo -e "    Status: $status"
      echo ""
      
      ((index++))
    fi
  done
  
  # tmux session status
  echo "----------------------------------------"
  if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    echo -e "  tmux: ${GREEN}Session '$TMUX_SESSION' active${NC}"
    echo -e "  Attach: ${CYAN}wt attach${NC}"
  else
    echo -e "  tmux: ${YELLOW}No active session${NC}"
    echo -e "  Start: ${CYAN}wt dev-all${NC}"
  fi
}

# Print path to worktree (for cd command)
cmd_cd() {
  local name="$1"
  
  if [[ -z "$name" ]]; then
    echo -e "${RED}Usage: cd \$(wt cd <name>)${NC}" >&2
    exit 1
  fi
  
  local target="$WORKTREES_DIR/$name"
  if [[ -d "$target" ]]; then
    echo "$target"
  else
    echo -e "${RED}Worktree not found: $name${NC}" >&2
    echo -e "Available: $(ls "$WORKTREES_DIR" 2>/dev/null | tr '\n' ' ')" >&2
    exit 1
  fi
}

# Start dev server in tmux
cmd_dev() {
  local name="$1"
  local target_dir
  local port
  
  if [[ -z "$name" ]]; then
    # Use current directory
    target_dir="$PWD"
    # Find port based on current worktree
    local current_name=$(basename "$PWD")
    port=$(get_worktree_port "$current_name")
  else
    target_dir="$WORKTREES_DIR/$name"
    port=$(get_worktree_port "$name")
  fi
  
  if [[ ! -d "$target_dir" ]]; then
    echo -e "${RED}Directory not found: $target_dir${NC}"
    exit 1
  fi
  
  local dev_cmd=$(get_dev_command "$target_dir" "$port")
  local window_name="${name:-$(basename "$target_dir")}"
  
  # Create or use existing tmux session
  if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    tmux new-session -d -s "$TMUX_SESSION" -n "$window_name" -c "$target_dir"
    tmux send-keys -t "$TMUX_SESSION:$window_name" "$dev_cmd" C-m
  else
    # Check if window exists
    if tmux list-windows -t "$TMUX_SESSION" | grep -q "$window_name"; then
      echo -e "${YELLOW}Window '$window_name' already exists${NC}"
    else
      tmux new-window -t "$TMUX_SESSION" -n "$window_name" -c "$target_dir"
      tmux send-keys -t "$TMUX_SESSION:$window_name" "$dev_cmd" C-m
    fi
  fi
  
  echo -e "${GREEN}‚úÖ Started${NC} $window_name on port $port"
  echo -e "   ${CYAN}wt attach${NC} to view"
  echo -e "   ${CYAN}open http://localhost:$port${NC}"
}

# Start all worktrees in tmux
cmd_dev_all() {
  echo -e "${CYAN}üöÄ Starting all worktrees...${NC}"
  
  # Kill existing session if exists
  tmux kill-session -t "$TMUX_SESSION" 2>/dev/null || true
  
  local first=true
  local index=0
  
  for wt in "$WORKTREES_DIR"/*/; do
    if [[ -d "$wt" ]]; then
      local name=$(basename "$wt")
      local port=$((BASE_PORT + index))
      local dev_cmd=$(get_dev_command "$wt" "$port")
      
      if $first; then
        tmux new-session -d -s "$TMUX_SESSION" -n "$name" -c "$wt"
        first=false
      else
        tmux new-window -t "$TMUX_SESSION" -n "$name" -c "$wt"
      fi
      
      tmux send-keys -t "$TMUX_SESSION:$name" "$dev_cmd" C-m
      echo -e "  ${GREEN}‚úÖ${NC} $name ‚Üí localhost:$port"
      
      ((index++))
    fi
  done
  
  if $first; then
    echo -e "${YELLOW}No worktrees found${NC}"
    return
  fi
  
  echo ""
  echo -e "${GREEN}All dev servers started!${NC}"
  echo ""
  echo -e "Commands:"
  echo -e "  ${CYAN}wt attach${NC}        - Attach to tmux session"
  echo -e "  ${CYAN}Ctrl+b, n${NC}        - Next window (next worktree)"
  echo -e "  ${CYAN}Ctrl+b, p${NC}        - Previous window"
  echo -e "  ${CYAN}Ctrl+b, 0-9${NC}      - Jump to window number"
  echo -e "  ${CYAN}Ctrl+b, w${NC}        - List all windows"
  echo -e "  ${CYAN}Ctrl+b, d${NC}        - Detach (servers keep running)"
}

# Stop dev server(s)
cmd_stop() {
  local name="$1"
  
  if [[ "$name" == "all" ]] || [[ -z "$name" ]]; then
    echo -e "${CYAN}Stopping all dev servers...${NC}"
    tmux kill-session -t "$TMUX_SESSION" 2>/dev/null || true
    echo -e "${GREEN}‚úÖ All stopped${NC}"
  else
    local port=$(get_worktree_port "$name")
    local pid=$(lsof -ti ":$port" 2>/dev/null)
    
    if [[ -n "$pid" ]]; then
      kill -9 $pid 2>/dev/null
      echo -e "${GREEN}‚úÖ Stopped${NC} $name (port $port)"
    else
      echo -e "${YELLOW}No server running on port $port${NC}"
    fi
    
    # Also kill tmux window if exists
    tmux kill-window -t "$TMUX_SESSION:$name" 2>/dev/null || true
  fi
}

# Attach to tmux session
cmd_attach() {
  if tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    tmux attach -t "$TMUX_SESSION"
  else
    echo -e "${YELLOW}No active session. Start with:${NC} wt dev-all"
  fi
}

# Show port assignments
cmd_ports() {
  echo -e "${CYAN}üì° Port Assignments${NC}"
  echo "===================="
  
  local index=0
  for wt in "$WORKTREES_DIR"/*/; do
    if [[ -d "$wt" ]]; then
      local name=$(basename "$wt")
      local port=$((BASE_PORT + index))
      local status=""
      
      if is_port_in_use "$port"; then
        status="${GREEN}‚óè${NC}"
      else
        status="${YELLOW}‚óã${NC}"
      fi
      
      echo -e "  $status localhost:$port ‚Üí $name"
      ((index++))
    fi
  done
}

# Open in browser
cmd_open() {
  local name="$1"
  local port
  
  if [[ -z "$name" ]]; then
    # Current directory
    local current_name=$(basename "$PWD")
    port=$(get_worktree_port "$current_name")
  else
    port=$(get_worktree_port "$name")
  fi
  
  local url="http://localhost:$port"
  echo -e "${CYAN}Opening $url${NC}"
  open "$url" 2>/dev/null || xdg-open "$url" 2>/dev/null || echo "Open manually: $url"
}

# Link environment files from main repo to worktree
cmd_link_env() {
  local target_wt="$1"
  local target_dir
  
  if [[ -z "$target_wt" ]]; then
    # Use current directory (must be in a worktree)
    target_dir=$(git rev-parse --show-toplevel 2>/dev/null)
  else
    target_dir="$WORKTREES_DIR/$target_wt"
  fi
  
  if [[ ! -d "$target_dir" ]]; then
    echo -e "${RED}Worktree not found: $target_dir${NC}"
    exit 1
  fi
  
  # Check if target is actually a worktree (not main repo)
  if [[ ! -f "$target_dir/.git" ]]; then
    if [[ "$target_dir" == "$PROJECT_ROOT" ]]; then
      echo -e "${YELLOW}Already in main repo, no need to link env files${NC}"
      return
    fi
  fi
  
  echo -e "${CYAN}üîó Linking environment files...${NC}"
  echo -e "   From: ${BLUE}$PROJECT_ROOT${NC}"
  echo -e "   To:   ${BLUE}$target_dir${NC}"
  echo ""
  
  # Common env file patterns
  local env_patterns=(".env" ".env.*" "*.local" "google-services.json" "GoogleService-Info.plist" ".secret*")
  local linked=0
  
  # Search in main repo (including subdirectories up to depth 4)
  for pattern in "${env_patterns[@]}"; do
    while IFS= read -r -d '' file; do
      # Get relative path from PROJECT_ROOT
      local rel_path="${file#$PROJECT_ROOT/}"
      local target_file="$target_dir/$rel_path"
      
      # Check if file is in .gitignore (only link ignored files)
      if git -C "$PROJECT_ROOT" check-ignore -q "$file" 2>/dev/null; then
        # Skip if already exists (file or symlink)
        if [[ -e "$target_file" ]] || [[ -L "$target_file" ]]; then
          echo -e "  ${YELLOW}‚è≠${NC}  $rel_path (already exists)"
          continue
        fi
        
        # Create parent directory if needed
        mkdir -p "$(dirname "$target_file")"
        
        # Create symlink
        ln -s "$file" "$target_file"
        echo -e "  ${GREEN}‚úÖ${NC} $rel_path"
        ((linked++))
      fi
    done < <(find "$PROJECT_ROOT" -maxdepth 4 -type f -name "$pattern" -print0 2>/dev/null)
  done
  
  echo ""
  if [[ $linked -eq 0 ]]; then
    echo -e "${YELLOW}No new env files to link${NC}"
  else
    echo -e "${GREEN}Linked $linked file(s)${NC}"
  fi
}

# Link env files to all worktrees
cmd_link_env_all() {
  echo -e "${CYAN}üîó Linking environment files to all worktrees...${NC}"
  echo ""
  
  if [[ ! -d "$WORKTREES_DIR" ]]; then
    echo -e "${YELLOW}No worktrees found${NC}"
    return
  fi
  
  for wt in "$WORKTREES_DIR"/*/; do
    if [[ -d "$wt" ]]; then
      local name=$(basename "$wt")
      echo -e "${BLUE}[$name]${NC}"
      cmd_link_env "$name"
      echo ""
    fi
  done
}

# Get install command for project type
get_install_command() {
  local dir="${1:-$PWD}"
  local project_type=$(detect_project_type "$dir")
  
  case $project_type in
    flutter)
      local flutter_dir=$(find_flutter_dir "$dir")
      if [[ "$flutter_dir" != "$dir" ]] && [[ -n "$flutter_dir" ]]; then
        echo "cd '$flutter_dir' && flutter pub get"
      else
        echo "flutter pub get"
      fi
      ;;
    nodejs)
      # Find package.json location
      local pkg_dir="$dir"
      local check_dirs=("$dir" "$dir/app" "$dir/src" "$dir/client" "$dir/frontend")
      for check_dir in "${check_dirs[@]}"; do
        if [[ -f "$check_dir/package.json" ]]; then
          pkg_dir="$check_dir"
          break
        fi
      done
      
      if [[ -f "$pkg_dir/package.json" ]]; then
        local cd_prefix=""
        if [[ "$pkg_dir" != "$dir" ]]; then
          cd_prefix="cd '$pkg_dir' && "
        fi
        
        # Detect package manager
        if [[ -f "$pkg_dir/pnpm-lock.yaml" ]]; then
          echo "${cd_prefix}pnpm install"
        elif [[ -f "$pkg_dir/yarn.lock" ]]; then
          echo "${cd_prefix}yarn install"
        elif [[ -f "$pkg_dir/bun.lockb" ]]; then
          echo "${cd_prefix}bun install"
        else
          echo "${cd_prefix}npm install"
        fi
      fi
      ;;
    go)
      echo "go mod download"
      ;;
    rust)
      echo "cargo fetch"
      ;;
    python)
      if [[ -f "$dir/pyproject.toml" ]]; then
        echo "pip install -e ."
      elif [[ -f "$dir/requirements.txt" ]]; then
        echo "pip install -r requirements.txt"
      else
        echo "echo 'No requirements found'"
      fi
      ;;
    *)
      echo "echo 'Unknown project type - cannot install'"
      ;;
  esac
}

# Install dependencies in a worktree
cmd_install() {
  local target_wt="$1"
  local target_dir
  
  if [[ -z "$target_wt" ]]; then
    # Use current directory
    target_dir=$(git rev-parse --show-toplevel 2>/dev/null)
  else
    target_dir="$WORKTREES_DIR/$target_wt"
  fi
  
  if [[ ! -d "$target_dir" ]]; then
    echo -e "${RED}Worktree not found: $target_dir${NC}"
    exit 1
  fi
  
  local project_type=$(detect_project_type "$target_dir")
  local install_cmd=$(get_install_command "$target_dir")
  
  echo -e "${CYAN}üì¶ Installing dependencies...${NC}"
  echo -e "   Path: ${BLUE}$target_dir${NC}"
  echo -e "   Type: $project_type"
  echo -e "   Command: $install_cmd"
  echo ""
  
  # Run install command
  (cd "$target_dir" && eval "$install_cmd")
  
  if [[ $? -eq 0 ]]; then
    echo ""
    echo -e "${GREEN}‚úÖ Dependencies installed successfully${NC}"
  else
    echo ""
    echo -e "${RED}‚ùå Installation failed${NC}"
    return 1
  fi
}

# Install dependencies in all worktrees
cmd_install_all() {
  echo -e "${CYAN}üì¶ Installing dependencies in all worktrees...${NC}"
  echo ""
  
  if [[ ! -d "$WORKTREES_DIR" ]]; then
    echo -e "${YELLOW}No worktrees found${NC}"
    return
  fi
  
  local success=0
  local failed=0
  
  for wt in "$WORKTREES_DIR"/*/; do
    if [[ -d "$wt" ]]; then
      local name=$(basename "$wt")
      echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
      echo -e "${BLUE}[$name]${NC}"
      echo ""
      
      if cmd_install "$name"; then
        ((success++))
      else
        ((failed++))
      fi
      echo ""
    fi
  done
  
  echo -e "${BLUE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
  echo ""
  echo -e "${CYAN}Summary:${NC}"
  echo -e "  ${GREEN}‚úÖ Success: $success${NC}"
  if [[ $failed -gt 0 ]]; then
    echo -e "  ${RED}‚ùå Failed: $failed${NC}"
  fi
}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# INTERACTIVE MODE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

declare -a WT_NAMES
declare -a WT_PATHS
declare -a WT_PORTS

load_worktrees_interactive() {
  WT_NAMES=()
  WT_PATHS=()
  WT_PORTS=()
  
  local index=0
  
  # Add main project
  local main_type=$(detect_project_type "$PROJECT_ROOT")
  if [[ "$main_type" != "generic" ]]; then
    WT_NAMES+=("main")
    WT_PATHS+=("$PROJECT_ROOT")
    WT_PORTS+=("$((BASE_PORT + index))")
    ((index++))
  fi
  
  # Add worktrees
  if [[ -d "$WORKTREES_DIR" ]]; then
    for wt in "$WORKTREES_DIR"/*/; do
      if [[ -d "$wt" ]]; then
        local name=$(basename "$wt")
        local port=$((BASE_PORT + index))
        WT_NAMES+=("$name")
        WT_PATHS+=("${wt%/}")
        WT_PORTS+=("$port")
        ((index++))
      fi
    done
  fi
}

read_key() {
  local key
  if ! IFS= read -rsn1 -t 1 key 2>/dev/null; then
    echo "TIMEOUT"
    return
  fi
  
  if [[ "$key" == $'\033' ]]; then
    read -rsn2 -t 0.1 key 2>/dev/null || true
    case "$key" in
      '[A') echo "UP" ;;
      '[B') echo "DOWN" ;;
      *) echo "ESC" ;;
    esac
  elif [[ "$key" == "" ]]; then
    echo "ENTER"
  elif [[ "$key" == $'\t' ]]; then
    echo "TAB"
  elif [[ "$key" == "q" || "$key" == "Q" ]]; then
    echo "QUIT"
  elif [[ "$key" =~ ^[1-9]$ ]]; then
    echo "NUM_$key"
  else
    echo "OTHER"
  fi
}

run_interactive_selector() {
  local session_name="$1"
  local selected_idx=0
  local current_wt=""
  
  printf '\033[?1049h'
  trap 'printf "\033[?1049l\033[?25h"' EXIT
  printf '\033[?25l'
  
  while true; do
    load_worktrees_interactive
    
    if [[ ${#WT_NAMES[@]} -eq 0 ]]; then
      printf '\033[H\033[J'
      echo -e "${RED}‚ùå No worktrees found${NC}"
      echo -e "${DIM}Create with: git worktree add ../${PROJECT_NAME}-worktrees/<name> <branch>${NC}"
      sleep 2
      continue
    fi
    
    if [[ $selected_idx -ge ${#WT_NAMES[@]} ]]; then
      selected_idx=$((${#WT_NAMES[@]} - 1))
    fi
    
    printf '\033[H\033[J'
    
    echo -e "${MAGENTA}‚îÅ‚îÅ${NC} ${BOLD}üå≥ wt${NC} ${DIM}($PROJECT_NAME)${NC} ${MAGENTA}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    if [[ -n "$current_wt" ]]; then
      local current_port=""
      for i in "${!WT_NAMES[@]}"; do
        if [[ "${WT_NAMES[$i]}" == "$current_wt" ]]; then
          current_port="${WT_PORTS[$i]}"
          break
        fi
      done
      echo -e "${GREEN}‚ñ∂${NC} ${BOLD}$current_wt${NC} ${DIM}| :$current_port${NC}"
    else
      echo -e "${DIM}No active worktree${NC}"
    fi
    echo ""
    
    for i in "${!WT_NAMES[@]}"; do
      local name="${WT_NAMES[$i]}"
      local num=$((i + 1))
      
      if [[ $i -eq $selected_idx ]]; then
        if [[ "$name" == "$current_wt" ]]; then
          echo -e "  ${GREEN}${BOLD}‚ñ∂ [$num] $name${NC} ${DIM}‚Üê running${NC}"
        else
          echo -e "  ${CYAN}${BOLD}‚ñ∂ [$num] $name${NC}"
        fi
      else
        if [[ "$name" == "$current_wt" ]]; then
          echo -e "    ${GREEN}[$num] $name${NC} ${DIM}‚Üê running${NC}"
        else
          echo -e "    ${DIM}[$num]${NC} $name"
        fi
      fi
    done
    
    echo ""
    echo -e "${DIM}[‚Üë‚Üì] Move  [Enter] Switch  [Tab] Dev pane  [q] Quit${NC}"
    
    local key_action=$(read_key)
    
    case "$key_action" in
      UP)
        if [[ $selected_idx -gt 0 ]]; then
          ((selected_idx--))
        else
          selected_idx=$((${#WT_NAMES[@]} - 1))
        fi
        ;;
      DOWN)
        if [[ $selected_idx -lt $((${#WT_NAMES[@]} - 1)) ]]; then
          ((selected_idx++))
        else
          selected_idx=0
        fi
        ;;
      ENTER)
        if [[ ${#WT_NAMES[@]} -gt 0 ]]; then
          local wt_name="${WT_NAMES[$selected_idx]}"
          local wt_path="${WT_PATHS[$selected_idx]}"
          local wt_port="${WT_PORTS[$selected_idx]}"
          current_wt="$wt_name"
          
          local dev_cmd=$(get_dev_command "$wt_path" "$wt_port")
          
          tmux set-option -t "$session_name" status-right " üìÇ $wt_name " 2>/dev/null || true
          
          tmux send-keys -t "${session_name}:0.1" C-c 2>/dev/null || true
          sleep 0.3
          tmux send-keys -t "${session_name}:0.1" "cd \"$wt_path\" && $dev_cmd" Enter 2>/dev/null || true
        fi
        ;;
      NUM_*)
        local num=${key_action#NUM_}
        local idx=$((num - 1))
        if [[ $idx -lt ${#WT_NAMES[@]} ]]; then
          selected_idx=$idx
          local wt_name="${WT_NAMES[$idx]}"
          local wt_path="${WT_PATHS[$idx]}"
          local wt_port="${WT_PORTS[$idx]}"
          current_wt="$wt_name"
          
          local dev_cmd=$(get_dev_command "$wt_path" "$wt_port")
          
          tmux set-option -t "$session_name" status-right " üìÇ $wt_name " 2>/dev/null || true
          
          tmux send-keys -t "${session_name}:0.1" C-c 2>/dev/null || true
          sleep 0.3
          tmux send-keys -t "${session_name}:0.1" "cd \"$wt_path\" && $dev_cmd" Enter 2>/dev/null || true
        fi
        ;;
      TAB)
        tmux select-pane -t "${session_name}:0.1" 2>/dev/null || true
        ;;
      QUIT)
        tmux kill-session -t "$session_name" 2>/dev/null || true
        exit 0
        ;;
    esac
  done
}

cleanup_interactive() {
  tmux kill-session -t "$INTERACTIVE_SESSION" 2>/dev/null || true
}

cmd_interactive() {
  if ! command -v tmux &>/dev/null; then
    echo -e "${RED}tmux required for interactive mode${NC}"
    echo -e "${DIM}Install: brew install tmux${NC}"
    exit 1
  fi
  
  trap cleanup_interactive EXIT
  
  local script_path=$(realpath "$0")
  
  tmux new-session -d -s "$INTERACTIVE_SESSION" -x "$(tput cols)" -y "$(tput lines)" \
    "\"$script_path\" --interactive-selector \"$INTERACTIVE_SESSION\""
  
  tmux set-option -t "$INTERACTIVE_SESSION" status-style "bg=cyan,fg=black,bold"
  tmux set-option -t "$INTERACTIVE_SESSION" status-left " üå≥ wt | "
  tmux set-option -t "$INTERACTIVE_SESSION" status-left-length 20
  tmux set-option -t "$INTERACTIVE_SESSION" status-right " üìÇ (none) "
  tmux set-option -t "$INTERACTIVE_SESSION" status-right-length 50
  tmux set-option -t "$INTERACTIVE_SESSION" mouse on
  tmux bind-key -n Tab select-pane -t :.+
  
  tmux set-option -t "$INTERACTIVE_SESSION" pane-border-style "fg=colour240"
  tmux set-option -t "$INTERACTIVE_SESSION" pane-active-border-style "fg=colour51"
  tmux set-option -t "$INTERACTIVE_SESSION" pane-border-status top
  tmux set-option -t "$INTERACTIVE_SESSION" pane-border-format " #{?pane_active,#[fg=colour51]‚ñ∂ ,  }#[fg=white,bold]#{pane_title}#[default] "
  
  tmux split-window -v -t "$INTERACTIVE_SESSION" -p 70 "bash"
  
  tmux select-pane -t "${INTERACTIVE_SESSION}:0.0" -T "üìã Worktree"
  tmux select-pane -t "${INTERACTIVE_SESSION}:0.1" -T "üöÄ Dev"
  
  tmux select-pane -t "${INTERACTIVE_SESSION}:0.0"
  
  tmux attach-session -t "$INTERACTIVE_SESSION"
}

SHELL_INTEGRATION='
# wt-cli (DO NOT EDIT)
wt() {
  if [[ "$1" == "cd" ]] && [[ -n "$2" ]]; then
    local target_dir
    target_dir=$(command wt cd "$2" 2>/dev/null)
    if [[ -n "$target_dir" ]] && [[ -d "$target_dir" ]]; then
      cd "$target_dir"
    else
      command wt cd "$2"
    fi
  else
    command wt "$@"
  fi
}
# wt-cli end'

cmd_setup() {
  local rc_file=""
  
  if [[ -n "$ZSH_VERSION" ]] || [[ "$SHELL" == *"zsh"* ]]; then
    rc_file="$HOME/.zshrc"
  elif [[ -n "$BASH_VERSION" ]] || [[ "$SHELL" == *"bash"* ]]; then
    rc_file="$HOME/.bashrc"
  elif [[ -f "$HOME/.zshrc" ]]; then
    rc_file="$HOME/.zshrc"
  elif [[ -f "$HOME/.bashrc" ]]; then
    rc_file="$HOME/.bashrc"
  fi
  
  if [[ -z "$rc_file" ]]; then
    echo -e "${YELLOW}Could not detect shell config file${NC}"
    echo "Run manually: wt shell-init >> ~/.zshrc"
    return 1
  fi
  
  if [[ -f "$rc_file" ]] && grep -q "wt-cli (DO NOT EDIT)" "$rc_file" 2>/dev/null; then
    echo -e "${GREEN}‚úÖ Shell integration already installed${NC}"
    return 0
  fi
  
  echo "$SHELL_INTEGRATION" >> "$rc_file"
  echo -e "${GREEN}‚úÖ Shell integration added to $rc_file${NC}"
  echo -e "   Run: ${CYAN}source $rc_file${NC} or restart terminal"
}

cmd_shell_init() {
  echo "$SHELL_INTEGRATION"
  echo ""
  echo "# To install automatically, run: wt setup"
}

# Show help
cmd_help() {
  echo -e "${CYAN}wt - Worktree Management CLI${NC}"
  echo ""
  echo "Usage: wt [command] [args]"
  echo ""
  echo "Interactive Mode (no args):"
  echo "  wt                Start interactive tmux UI"
  echo "                    ‚Üë/‚Üì to select, Enter to start dev server"
  echo ""
  echo "Commands:"
  echo "  ls, list          List all worktrees and their status"
  echo "  cd <name>         Change to worktree directory"
  echo "                    (requires shell-init, or use: cd \$(wt cd <name>))"
  echo "  dev [name]        Start dev server in tmux"
  echo "  dev-all           Start all worktrees in tmux session"
  echo "  stop [name|all]   Stop dev server(s)"
  echo "  attach            Attach to tmux session"
  echo "  ports             Show port assignments"
  echo "  open [name]       Open in browser"
  echo "  link-env [name]   Link .env files from main repo to worktree"
  echo "  link-env-all      Link .env files to all worktrees"
  echo "  install [name]    Install dependencies in worktree"
  echo "  install-all       Install dependencies in all worktrees"
  echo "  setup             Install shell integration (run once after install)"
  echo "  shell-init        Output shell integration script"
  echo ""
  echo "tmux Shortcuts (after 'wt attach'):"
  echo "  Ctrl+b, n         Next window (next worktree)"
  echo "  Ctrl+b, p         Previous window"
  echo "  Ctrl+b, 0-9       Jump to window number"
  echo "  Ctrl+b, w         List all windows"
  echo "  Ctrl+b, d         Detach (servers keep running)"
  echo ""
  echo "Examples:"
  echo "  wt ls                    # Show all worktrees"
  echo "  wt dev-all               # Start all dev servers"
  echo "  wt attach                # View in tmux"
  echo "  cd \$(wt cd feature-auth) # Change to worktree"
  echo "  wt open feature-auth     # Open in browser"
  echo "  wt stop all              # Stop all servers"
}

# Main command router
case "${1:-}" in
  --interactive-selector)
    shift
    run_interactive_selector "$@"
    exit 0
    ;;
  "")
    cmd_interactive
    ;;
  ls|list)
    cmd_list
    ;;
  cd)
    cmd_cd "$2"
    ;;
  dev)
    cmd_dev "$2"
    ;;
  dev-all)
    cmd_dev_all
    ;;
  stop)
    cmd_stop "$2"
    ;;
  attach)
    cmd_attach
    ;;
  ports)
    cmd_ports
    ;;
  open)
    cmd_open "$2"
    ;;
  link-env)
    cmd_link_env "$2"
    ;;
  link-env-all)
    cmd_link_env_all
    ;;
  install)
    cmd_install "$2"
    ;;
  install-all)
    cmd_install_all
    ;;
  setup)
    cmd_setup
    ;;
  shell-init)
    cmd_shell_init
    ;;
  help|--help|-h)
    cmd_help
    ;;
  *)
    echo -e "${RED}Unknown command: $1${NC}"
    echo ""
    cmd_help
    exit 1
    ;;
esac
